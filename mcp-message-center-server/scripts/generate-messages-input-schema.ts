import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

type OpenApiParameter = {
  name: string;
  in: 'query' | 'header' | 'path' | 'cookie';
  required?: boolean;
  description?: string;
  schema?: {
    type?: string;
    minimum?: number;
    maximum?: number;
    default?: unknown;
  };
  $ref?: string;
};

type OpenApiDoc = {
  paths?: Record<string, any>;
  components?: Record<string, any>;
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function readJson(filePath: string) {
  return JSON.parse(fs.readFileSync(filePath, 'utf8')) as OpenApiDoc;
}

function resolveRef(doc: any, ref: string): any {
  if (!ref.startsWith('#/')) {
    throw new Error(`Only local refs are supported. Got: ${ref}`);
  }
  const parts = ref.slice(2).split('/');
  let cur: any = doc;
  for (const p of parts) {
    cur = cur?.[p];
    if (cur === undefined) {
      throw new Error(`Unresolvable ref ${ref} at ${p}`);
    }
  }
  return cur;
}

function normalizeDescription(text: unknown): string | undefined {
  if (typeof text !== 'string') return undefined;
  return text.replace(/\s+/g, ' ').trim();
}

function zodForParam(key: string, param: OpenApiParameter): string {
  const schema = param.schema ?? {};
  const desc = normalizeDescription(param.description);

  const normalizedDefault = (() => {
    const d = schema.default;
    switch (schema.type) {
      case 'boolean': {
        if (typeof d === 'boolean') return d;
        if (typeof d === 'string') {
          const v = d.trim().toLowerCase();
          if (v === 'true') return true;
          if (v === 'false') return false;
        }
        return d;
      }
      case 'integer': {
        if (typeof d === 'number') return d;
        if (typeof d === 'string') {
          const n = Number(d);
          return Number.isFinite(n) ? n : d;
        }
        return d;
      }
      default:
        return d;
    }
  })();

  const base = (() => {
    switch (schema.type) {
      case 'string':
        return 'z.string()';
      case 'integer': {
        const parts = ['z.number().int()'];
        // Policy override: keep MCP behavior allowing top=0 (count-only).
        const min = key === 'top' ? 0 : schema.minimum;
        if (typeof min === 'number') parts.push(`.min(${min})`);
        if (typeof schema.maximum === 'number') parts.push(`.max(${schema.maximum})`);
        return parts.join('');
      }
      case 'boolean':
        return 'z.boolean()';
      default:
        return 'z.string()';
    }
  })();

  const withDefault =
    normalizedDefault !== undefined ? `${base}.default(${JSON.stringify(normalizedDefault)})` : base;

  // Prefer defaults when present; otherwise optional unless required.
  const withOptional =
    normalizedDefault !== undefined ? withDefault : param.required ? withDefault : `${withDefault}.optional()`;

  return desc ? `${withOptional}.describe(${JSON.stringify(desc)})` : withOptional;
}

function main() {
  const openApiPath = path.resolve(__dirname, '../openapi/openapi.json');
  const doc = readJson(openApiPath);

  const op = doc.paths?.['/admin/serviceAnnouncement/messages']?.get;
  if (!op) {
    throw new Error(`Operation not found: GET /admin/serviceAnnouncement/messages`);
  }

  const rawParams: any[] = Array.isArray(op.parameters) ? op.parameters : [];
  const parameters: OpenApiParameter[] = rawParams.map((p) =>
    p?.$ref ? (resolveRef(doc, p.$ref) as OpenApiParameter) : (p as OpenApiParameter)
  );

  const byKey = new Map(parameters.map((p) => [`${p.in}:${p.name}`, p]));

  const orderby = byKey.get('query:$orderby');
  const count = byKey.get('query:$count');
  const prefer = byKey.get('header:Prefer');
  const top = byKey.get('query:$top');
  const skip = byKey.get('query:$skip');
  const filter = byKey.get('query:$filter');

  if (!orderby || !count || !prefer || !top || !skip || !filter) {
    throw new Error(
      `Missing expected parameters. Found: ${parameters.map((p) => `${p.in}:${p.name}`).join(', ')}`
    );
  }

  // MCP-friendly keys
  const entries: Array<[string, OpenApiParameter]> = [
    ['orderby', orderby],
    ['count', count],
    ['prefer', prefer],
    ['top', top],
    ['skip', skip],
    ['filter', filter]
  ];

  const output = `/* eslint-disable */\n// Generated by scripts/generate-messages-input-schema.ts\nimport * as z from 'zod';\n\nexport const getMessagesInputSchemaBase = {\n${entries
    .map(([k, p]) => `  ${k}: ${zodForParam(k, p)},`)
    .join('\n')}\n} as const;\n`;

  const outDir = path.resolve(__dirname, '../src/generated');
  fs.mkdirSync(outDir, { recursive: true });

  const outFile = path.join(outDir, 'messagesInputSchema.ts');
  fs.writeFileSync(outFile, output, 'utf8');
  console.log(`Generated: ${outFile}`);
}

main();
