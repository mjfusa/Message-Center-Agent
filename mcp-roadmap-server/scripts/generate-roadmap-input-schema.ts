import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

type OpenApiParameter = {
  name: string;
  in: string;
  required?: boolean;
  description?: string;
  schema?: {
    type?: string;
    minimum?: number;
    maximum?: number;
    default?: unknown;
  };
  $ref?: string;
};

type OpenApiDoc = {
  paths?: Record<string, any>;
  components?: { parameters?: Record<string, any> };
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function readJson(filePath: string) {
  return JSON.parse(fs.readFileSync(filePath, 'utf8')) as OpenApiDoc;
}

function resolveRef(doc: any, ref: string): any {
  if (!ref.startsWith('#/')) {
    throw new Error(`Only local refs are supported. Got: ${ref}`);
  }
  const parts = ref.slice(2).split('/');
  let cur: any = doc;
  for (const p of parts) {
    cur = cur?.[p];
    if (cur === undefined) {
      throw new Error(`Unresolvable ref ${ref} at ${p}`);
    }
  }
  return cur;
}

function normalizeDescription(text: unknown): string | undefined {
  if (typeof text !== 'string') return undefined;
  return text.replace(/\s+/g, ' ').trim();
}

function paramToZod(key: string, param: OpenApiParameter): string {
  const schema = param.schema ?? {};
  const desc = normalizeDescription(param.description);

  const normalizedDefault = (() => {
    const d = schema.default;
    switch (schema.type) {
      case 'boolean': {
        if (typeof d === 'boolean') return d;
        if (typeof d === 'string') {
          const v = d.trim().toLowerCase();
          if (v === 'true') return true;
          if (v === 'false') return false;
        }
        return d;
      }
      case 'integer': {
        if (typeof d === 'number') return d;
        if (typeof d === 'string') {
          const n = Number(d);
          return Number.isFinite(n) ? n : d;
        }
        return d;
      }
      default:
        return d;
    }
  })();

  const zBase = (() => {
    switch (schema.type) {
      case 'string':
        return 'z.string()';
      case 'integer': {
        const min = typeof schema.minimum === 'number' ? schema.minimum : undefined;
        const max = typeof schema.maximum === 'number' ? schema.maximum : undefined;

        // Policy override: allow top=0 for count-only queries in MCP.
        const effectiveMin = key === 'top' ? 0 : min;

        const parts = ['z.number().int()'];
        if (typeof effectiveMin === 'number') parts.push(`.min(${effectiveMin})`);
        if (typeof max === 'number') parts.push(`.max(${max})`);
        return parts.join('');
      }
      case 'boolean':
        return 'z.boolean()';
      default:
        return 'z.string()';
    }
  })();

  // Keep parity with existing behavior: count defaults true; others optional.
  const wantsDefault = key === 'count' && typeof normalizedDefault === 'boolean';
  const zWithDefault = wantsDefault ? `${zBase}.default(${normalizedDefault})` : zBase;
  const zFinal = wantsDefault ? zWithDefault : `${zWithDefault}.optional()`;

  return desc ? `${zFinal}.describe(${JSON.stringify(desc)})` : zFinal;
}

function main() {
  const openApiPath = path.resolve(__dirname, '../openapi/roadmap-openapi.json');
  const doc = readJson(openApiPath);

  const op = doc.paths?.['/m365']?.get;
  if (!op) {
    throw new Error(`OpenAPI operation not found at paths['/m365'].get`);
  }

  const parameters: any[] = Array.isArray(op.parameters) ? op.parameters : [];
  const resolvedParams: OpenApiParameter[] = parameters.map((p) =>
    p?.$ref ? (resolveRef(doc, p.$ref) as OpenApiParameter) : (p as OpenApiParameter)
  );

  const byName = new Map(resolvedParams.map((p) => [p.name, p]));
  const filter = byName.get('$filter');
  const orderby = byName.get('$orderby');
  const top = byName.get('$top');
  const skip = byName.get('$skip');
  const count = byName.get('$count');

  if (!filter || !orderby || !top || !skip || !count) {
    throw new Error(`Missing expected parameters. Found: ${resolvedParams.map((p) => p.name).join(', ')}`);
  }

  const patchedTop: OpenApiParameter = {
    ...top,
    description: `${normalizeDescription(top.description) ?? ''} Set to 0 for count-only.`.trim()
  };

  const entries: Array<[string, OpenApiParameter]> = [
    ['filter', filter],
    ['orderby', orderby],
    ['top', patchedTop],
    ['skip', skip],
    ['count', count]
  ];

  const output = `/* eslint-disable */\n// Generated by scripts/generate-roadmap-input-schema.ts\nimport * as z from 'zod';\n\nexport const getRoadmapInputSchema = {\n${entries
    .map(([k, p]) => `  ${k}: ${paramToZod(k, p)},`)
    .join('\n')}\n} as const;\n`;

  const outDir = path.resolve(__dirname, '../src/generated');
  fs.mkdirSync(outDir, { recursive: true });

  const outFile = path.join(outDir, 'roadmapInputSchema.ts');
  fs.writeFileSync(outFile, output, 'utf8');
  console.log(`Generated: ${outFile}`);
}

main();
